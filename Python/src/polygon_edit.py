from src import geometry_core as g
from src import dataset as d
from src import polygon_convex_cutter as pc
from src import polygon_concave_cutter as pcc

### \class contains auxiliary methods for the cutting of the polygon
class PolygonEdit(g.IPolygonEdit):
    ### \brief construct the reference to GeometryFactory
    def __init__(self, problem: g.IGeometryFactory):
        self.__problem = problem
    ### /// Getter

    ### \brief GetProblem() returns the interface of GeometryFactory
    def get_problem(self) -> g.IGeometryFactory:
        return self.__problem

    ### \brief GetPoint(i) returns the i-th point in _points (N.B. not sorted) in _problem
    def GetPoint(self, id: int) -> d.Point:
        return self.__problem.GetPoint(id)

    ### \brief CheckSide(point_id, line) returns an integer in the set { -1, 0, 1 }, which labels the position of a point with respect to the segment
    ### if not specified, the "line" input would be assumed as the cutting line
    def check_side_l(self, point_id: int, line: d.Segment) -> int:
        point = self.GetPoint(point_id) # punto da controllare
        tol = 1e-7
        # prendo il punto di inizio e di fine del segmento tagliante (che è dato in input)
        point_from = self.GetPoint(line.From)
        point_to = self.GetPoint(line.To)

        # vpoint è il vettore 3d che corrisponde al segmento che va dal punto considerato all'origine del segmento tagliante
        vpoint = d.Point(point.x - point_from.x, point.y - point_from.y)
        # vline è il vettore 3d che corrisponde al segmento tagliante
        vline = d.Point(point_to.x - point_from.x, point_to.y - point_from.y)
        cross = vline.x * vpoint.y - vline.y * vpoint.x

        # exit equivale a  side: -1 right, 0 on line, 1 left
        if cross > tol:
            exit = 1 # sinistra
        elif cross < -tol:
            exit = -1 # destra
        else:
            exit = 0 # sulla linea

        return exit

    ### \brief CheckSide(point_id) returns an integer in the set { -1, 0, 1 }, which labels the position of a point with respect to the segment
    ### if not specified, the "line" input would be assumed as the cutting line
    def check_side(self, point_id: int) -> int:
        point = self.GetPoint(point_id) # punto da controllare
        tol = 1e-7
        # prendo il punto di inizio e di fine del segmento tagliante
        point_from = self.get_problem().GetPoint(self.get_problem().GetLine().From)
        point_to = self.get_problem().GetPoint(self.get_problem().GetLine().To)

        # vpoint è il vettore 3d che corrisponde al segmento che va dal punto considerato all'origine del segmento tagliante
        vpoint = d.Point(point.x - point_from.x, point.y - point_from.y)
        # vline è il vettore 3d che corrisponde al segmento tagliante
        vline = d.Point(point_to.x - point_from.x, point_to.y - point_from.y)
        cross = vline.x * vpoint.y - vline.y * vpoint.x

        # exit equivale a  side: -1 right, 0 on line, 1 left
        if cross > tol:
            exit = 1 # sinistra
        elif cross < -tol:
            exit = -1 # destra
        else:
            exit = 0 # sulla linea

        return exit

    ### \brief CheckConvexity() establish the convexity of the polygon
    def check_convexity(self) -> bool:
        exit = True # è convesso?
        n = self.__problem.GetPolygon().number_vertices
        vertices = self.__problem.GetPolygon().polygon_vertices
        i = 0
        while i < n and exit: # per ogni lato del poligono controllo che tutti i punti del poligono che non apprtengono al lato siano a sinistra del lato
            if self.check_side_l(vertices[(i+2) % n], self.__problem.GetPolygonEdge(i)) != 1:
                exit = False # seun punto è a destra del segmento,allora il poligono non è convesso
            i += 1
        return exit

    ### \brief CheckExternal() establish the exernity of the cutting line with respect to the polygon
    def check_external(self) -> bool:
        exitt = True # il segmento tagliante è esternoa l poligono?
        vertices = self.__problem.GetPolygon().polygon_vertices
        sample = self.check_side(vertices[0])
        i = 1
        while i < len(vertices) and sample and exitt:
            if not self.check_side(vertices[i]) == sample: # se un punto è dalla parte opposta rispetto al primo vertice
                exitt = False
            i += 1

        # se il primo vertice non appartiene al segmento tagliante e non esiste nessun punto che si trovi dalla parte opposta
        # rispetto al primo vertice allora la retta è esterna al poligono
        return (exitt and sample)

    ### \brief CutPolygon() compute the sub-Polygons generated by the cut of the initial polygon with line
    def cut_polygon(self):
        if self.check_external(): # se il segmento tahliante è esterno al poligono
            self.__problem = self.__problem.SetSubPolygons(self.__problem.GetPolygon()) # setta un subpoligono
            return

        if self.check_convexity(): # se il poligono è convesso
            cutter = pc.ConvexCutter(self)

            cutter.compute_new_points()
            cutter.find_sub_polygons()
        else: # altrimenti se il poligono è concavo
            cutter = pcc.ConcaveCutter(self)

            cutter.compute_new_points()
            cutter.find_sub_polygons()

        return




