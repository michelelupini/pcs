from src import geometry_core as g
from src import dataset as d

### \class: contains data of the cutting problem
class GeometryFactory(g.IGeometryFactory):
    def __init__(self):
        self.__geometryFilePath: str                        ### \param: path of the input
        self.__initialPolygon: d.Polygon = d.Polygon([])    ### \param initial polygon to be cutted
        self.__initialEdges = []                            ### \param: segments of the initial polygon
        self.__line: d.Segment = d.Segment(-1, -1)          ### \param: cutting line
        self.__points = []                                  ### \param: vector of all the points (not sorted) charactrerized by an index
        self.__subPolygons = []                             ### \param: vector of new sub-polygons generated by cutting the initial one

    ### \brief: reset all the variables
    def ResetFactory(self):
        self.__initialPolygon.number_vertices = 0
        self.__initialPolygon.polygon_vertices = []
        self.__line.From = -1
        self.__line.To = -1
        self.__points = []
        self.__initialEdges = []
        self.__subPolygons = []

    ### \brief: CreatePolygon("input.txt") creates the initial polygon and sets the initial condition to compute the cut, through an input file
    def CreatePolygon(self, file_path: str):
        g.IGeometryFactory.ResetFactory(self)
        self.__geometryFilePath = file_path

        ### Open file
        try:
            file = open(self.__geometryFilePath, 'r')
        except IOError:
            raise RuntimeError("Cannot open file. Something went wrong")

        ### Load input
        try:
            ### Get points
            line = file.readline()
            check = line[0:6]  # check if the identifier of the line is correct
            if check != "points":  # check if the user want to set a list of points
                raise ValueError('bad points input')
            else:
                line = line.replace('points = { ', '').replace('{', '').replace('}', '').replace(';', '').replace(',', '')
                coordinates_list = [float(c) for c in line.split()]
                self.__points = [d.Point(coordinates_list[2*n], coordinates_list[2*n + 1]) for n in range(0, int(len(coordinates_list)/2))]

            ### Get polygon vertices: construct initial polygon(vertices and segments)
            line = file.readline()
            check = line[0:15]
            if check != "polygonVertices":  # check if the user want to set a list of polygon vertices
                raise ValueError('bad polygon vertices input')
            else:
                line = line.replace('polygonVertices = { ', '').replace('{', '').replace('}', '').replace(',', '')
                self.__initialPolygon.polygon_vertices = [int(c) for c in line.split()]  # construct polygon vertices
                self.__initialPolygon.number_vertices = len(self.__initialPolygon.polygon_vertices)
                for i in range(1, self.__initialPolygon.number_vertices):
                    self.__initialEdges.append(d.Segment(self.__initialPolygon.polygon_vertices[i - 1],
                                                         self.__initialPolygon.polygon_vertices[i]))
                    # construct polygon segments
                self.__initialEdges.append(d.Segment(self.__initialPolygon.polygon_vertices[self.__initialPolygon.number_vertices - 1],
                                                     self.__initialPolygon.polygon_vertices[0]))
                # construct the last segment

            ### Get segment
            line = file.readline()
            check = line[0:7]
            if check != "segment":  # check if the user want to set the line
                raise ValueError('bad segment input')
            else:
                line = line.replace('segment = { ', '').replace('{', '').replace('}', '').replace(';', '').replace(',', '')
                coordinates_list = [float(c) for c in line.split()]
                self.__points += [d.Point(coordinates_list[2 * n], coordinates_list[2 * n + 1]) for n in
                                 range(0, int(len(coordinates_list) / 2))]
                #self.__points += segmentPoint
                self.__line.From = self.__initialPolygon.number_vertices
                self.__line.To = self.__initialPolygon.number_vertices + 1

            ### Close file
            file.close()

        except Exception as ex:
            ### Close file
            file.close()

            if repr(ex.args[0]) == "'bad points input'" or \
                repr(ex.args[0]) == "'bad polygon vertices input'" or \
                repr(ex.args[0]) == "'bad segment input'":
                raise RuntimeError("Syntax error: " + repr(ex.args[0]))
            else:
                raise RuntimeError("Something went wrong")

        ### Close file
        file.close()

    ### Getters
    ### \brief GetPointsNumber() returns the number of all the points in _points
    ### \brief GetPolygon() returns the initial polygon
    ### \brief GetPolygonEdge(i) returns the i-th initial polygon edge
    ### \brief GetAllEdges() returns the vector of edges of the initial polygon
    ### \brief GetLine() returns the cutting line
    ### \brief GetPoint(i) returns the i-th point in _points (N.B. not sorted)
    ### \brief GetPointAddress(point) returns the integer that identifies point in _points, if there is not the point it returns -1
    ### \brief GetNumberSubPolygons() returns the number of sub-polygons _subPolygons
    ### \brief GetSubPolygon(i) returns the i-th sub-polygon generated by cutting the initial one
    ### \brief GetAllSubPolygons() return the vector of sub-polygons

    def GetPointsNumber(self) -> int:
        return len(self.__points)

    def GetPolygon(self) -> d.Polygon:
        return self.__initialPolygon

    def GetPolygonEdge(self, edge_position: int) -> d.Segment:
        return self.__initialEdges[edge_position]

    def GetAllEdges(self) -> []:
        return self.__initialEdges

    def GetLine(self) -> d.Segment:
        return self.__line

    def GetPoint(self, id_point: int) -> d.Point:
        return self.__points[id_point]

    def GetPointAddress(self, point: d.Point) -> int:
        for i in range(0, self.GetPointsNumber()):
            if point == self.__points[i]:
                return i
        return -1

    def GetNumberSubPolygons(self) -> int:
        return len(self.__subPolygons)

    def GetSubPolygon(self, id_polygon: int) -> d.Polygon:
        return self.__subPolygons[id_polygon]

    def GetAllSubPolygons(self) -> []:
        return self.__subPolygons

    ### Setters
    ### \brief SetPoints(point) add point to _points
    ### \brief SetSubPolygons(polygon) add polygon to _subPolygons

    def SetPoints(self, point: d.Point) -> int:
        self.__points.append(point)
        return len(self.__points) - 1

    def SetSubPolygons(self, new_sub_polygon: d.Polygon) -> int:
        self.__subPolygons.append(new_sub_polygon)
        return len(self.__subPolygons) - 1
